// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;
extern crate flatbuffers;
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::mem;
use core::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum FileStatisticsOffset {}
#[derive(Copy, Clone, PartialEq)]

/// File statistics and quality metrics
pub struct FileStatistics<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FileStatistics<'a> {
  type Inner = FileStatistics<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FileStatistics<'a> {
  pub const VT_CREATION_TIMESTAMP: flatbuffers::VOffsetT = 4;
  pub const VT_LAST_MODIFIED: flatbuffers::VOffsetT = 6;
  pub const VT_TOTAL_SIZE: flatbuffers::VOffsetT = 8;
  pub const VT_INTEGRITY_HASH: flatbuffers::VOffsetT = 10;
  pub const VT_VECTOR_QUALITY_SCORE: flatbuffers::VOffsetT = 12;
  pub const VT_INDEX_QUALITY_METRICS: flatbuffers::VOffsetT = 14;
  pub const VT_BUILD_TOOL: flatbuffers::VOffsetT = 16;
  pub const VT_BUILD_VERSION: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FileStatistics { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FileStatisticsArgs<'args>
  ) -> flatbuffers::WIPOffset<FileStatistics<'bldr>> {
    let mut builder = FileStatisticsBuilder::new(_fbb);
    builder.add_total_size(args.total_size);
    builder.add_last_modified(args.last_modified);
    builder.add_creation_timestamp(args.creation_timestamp);
    if let Some(x) = args.build_version { builder.add_build_version(x); }
    if let Some(x) = args.build_tool { builder.add_build_tool(x); }
    if let Some(x) = args.index_quality_metrics { builder.add_index_quality_metrics(x); }
    builder.add_vector_quality_score(args.vector_quality_score);
    if let Some(x) = args.integrity_hash { builder.add_integrity_hash(x); }
    builder.finish()
  }


  #[inline]
  pub fn creation_timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(FileStatistics::VT_CREATION_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_modified(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(FileStatistics::VT_LAST_MODIFIED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn total_size(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(FileStatistics::VT_TOTAL_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn integrity_hash(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FileStatistics::VT_INTEGRITY_HASH, None)}
  }
  #[inline]
  pub fn vector_quality_score(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FileStatistics::VT_VECTOR_QUALITY_SCORE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn index_quality_metrics(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FileStatistics::VT_INDEX_QUALITY_METRICS, None)}
  }
  #[inline]
  pub fn build_tool(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FileStatistics::VT_BUILD_TOOL, None)}
  }
  #[inline]
  pub fn build_version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FileStatistics::VT_BUILD_VERSION, None)}
  }
}

impl flatbuffers::Verifiable for FileStatistics<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("creation_timestamp", Self::VT_CREATION_TIMESTAMP, false)?
     .visit_field::<u64>("last_modified", Self::VT_LAST_MODIFIED, false)?
     .visit_field::<u64>("total_size", Self::VT_TOTAL_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("integrity_hash", Self::VT_INTEGRITY_HASH, false)?
     .visit_field::<f32>("vector_quality_score", Self::VT_VECTOR_QUALITY_SCORE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("index_quality_metrics", Self::VT_INDEX_QUALITY_METRICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("build_tool", Self::VT_BUILD_TOOL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("build_version", Self::VT_BUILD_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct FileStatisticsArgs<'a> {
    pub creation_timestamp: u64,
    pub last_modified: u64,
    pub total_size: u64,
    pub integrity_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub vector_quality_score: f32,
    pub index_quality_metrics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub build_tool: Option<flatbuffers::WIPOffset<&'a str>>,
    pub build_version: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FileStatisticsArgs<'a> {
  #[inline]
  fn default() -> Self {
    FileStatisticsArgs {
      creation_timestamp: 0,
      last_modified: 0,
      total_size: 0,
      integrity_hash: None,
      vector_quality_score: 0.0,
      index_quality_metrics: None,
      build_tool: None,
      build_version: None,
    }
  }
}

pub struct FileStatisticsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FileStatisticsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_creation_timestamp(&mut self, creation_timestamp: u64) {
    self.fbb_.push_slot::<u64>(FileStatistics::VT_CREATION_TIMESTAMP, creation_timestamp, 0);
  }
  #[inline]
  pub fn add_last_modified(&mut self, last_modified: u64) {
    self.fbb_.push_slot::<u64>(FileStatistics::VT_LAST_MODIFIED, last_modified, 0);
  }
  #[inline]
  pub fn add_total_size(&mut self, total_size: u64) {
    self.fbb_.push_slot::<u64>(FileStatistics::VT_TOTAL_SIZE, total_size, 0);
  }
  #[inline]
  pub fn add_integrity_hash(&mut self, integrity_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FileStatistics::VT_INTEGRITY_HASH, integrity_hash);
  }
  #[inline]
  pub fn add_vector_quality_score(&mut self, vector_quality_score: f32) {
    self.fbb_.push_slot::<f32>(FileStatistics::VT_VECTOR_QUALITY_SCORE, vector_quality_score, 0.0);
  }
  #[inline]
  pub fn add_index_quality_metrics(&mut self, index_quality_metrics: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FileStatistics::VT_INDEX_QUALITY_METRICS, index_quality_metrics);
  }
  #[inline]
  pub fn add_build_tool(&mut self, build_tool: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FileStatistics::VT_BUILD_TOOL, build_tool);
  }
  #[inline]
  pub fn add_build_version(&mut self, build_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FileStatistics::VT_BUILD_VERSION, build_version);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FileStatisticsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FileStatisticsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FileStatistics<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FileStatistics<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FileStatistics");
      ds.field("creation_timestamp", &self.creation_timestamp());
      ds.field("last_modified", &self.last_modified());
      ds.field("total_size", &self.total_size());
      ds.field("integrity_hash", &self.integrity_hash());
      ds.field("vector_quality_score", &self.vector_quality_score());
      ds.field("index_quality_metrics", &self.index_quality_metrics());
      ds.field("build_tool", &self.build_tool());
      ds.field("build_version", &self.build_version());
      ds.finish()
  }
}
